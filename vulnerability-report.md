#Vulnerability Report
Reviewer 1: Ted Callahan
Reviewer 2: Rick Valenzuela

Date: February 1st, 2017

##Reviewing Joey Derosa's Learning Journal
site: https://github.com/JoeyDeRosa/learning_journal

##Vulnerability A7: Missing Function Level Access Control
###Exposure
Derosa's site has unprotected access to create a journal entry. We were able to click on "New Entry" and make a new post.

###Repair
Authentication checks must be added. A function should make the check, and it should be invoked before views that need to be protected.


###Solution:
####Method 1:
This can be solved with an explicit check for permission inside the function, or with a more general solution implementing permissions decorators (for function views) or mixins (for class based views). See Vulnerability 7 for details on using the mixins and decorators.  Alternatively, an explicit check can be used to verify permissions stored on the user object in the view.

if user.has_perm('can_change_group'):

To use this properly, the site must be set up to assign appropriate permissions and users when new users are created.

To define permissions and groups the user can create new Model permissions by declaring them in the Models as such:
class ExampleModel(models.Model):
    class Meta:
        permissions = (
            ("view_model", "Can view model")
        )

Then, when creating Users, add the permission to that instance of the user model or make it a part of a model tied to the user model (e.g. a Profile model.)

####Method 2:
In addition to adding a basic authentication policy for logins, the site From the [Pyramid documentation](http://docs.pylonsproject.org/projects/pyramid_cookbook/en/latest/auth/user_object.html), a security check can be added with a lazy property to call an auth-check function on certain views. For instance:
```
from pyramid.security import unauthenticated_userid

def get_user(request):
    # the below line is just an example, use your own method of
    # accessing a database connection here (this could even be another
    # request property such as request.db, implemented using this same
    # pattern).
    dbconn = request.registry.settings['dbconn']
    userid = unauthenticated_userid(request)
    if userid is not None:
        # this should return None if the user doesn't exist
        # in the database
        return dbconn['users'].query({'id':userid})
```
and
```
config.add_request_method(get_user, 'user', reify=True)
```
can be used to extend the user request object. Then, on view functions that perform any CRUD actions, `request.user` should be used, which will allow access if credentials are associated with the request.
